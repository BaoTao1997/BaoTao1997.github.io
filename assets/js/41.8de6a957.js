(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{246:function(e,t,n){"use strict";n.r(t);var r=n(0),s=Object(r.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Node.js开发指南")]),e._v(" "),n("p",[e._v("Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事件由 EventEmitter 对象提供。前面提到的 fs.readFile 和 http.createServer 的回调函数都是通过 EventEmitter 来实现的。下面我们用一个简单的例子说明 EventEmitter的用法：\n//event.js\nvar EventEmitter = require('events').EventEmitter;\nvar event = new EventEmitter();\nevent.on('some_event', function() {\nconsole.log('some_event occured.');\n});\nsetTimeout(function() {\nevent.emit('some_event');\n}, 1000);\n运行这段代码， 1秒后控制台输出了 some_event occured.。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在1000毫秒以后向event 对象发送事件 some_event，此时会调用 some_event 的监听器")]),e._v(" "),n("p",[e._v("所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（ emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。图3-5说明了事件循环的原理。")]),e._v(" "),n("p",[e._v("Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口， require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象，因为require 不会重复加载模块，也就是说无论调用多少次 require， 获得的模块都是同一个 。")]),e._v(" "),n("p",[e._v("不可以通过对 exports 直接赋值代替对 module.exports 赋值。exports 实际上只是一个和 module.exports 指向同一个对象的变量，它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定module.exports 来改变访问接口。")]),e._v(" "),n("p",[e._v("Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。")]),e._v(" "),n("p",[e._v("使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。我们会在第 6 章详细介绍模块的加载顺序。")]),e._v(" "),n("p",[e._v("模 式 可通过 require 使用 注册PATH\n本地模式 是 否\n全局模式 否 是")]),e._v(" "),n("h3",{attrs:{id:"process"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#process","aria-hidden":"true"}},[e._v("#")]),e._v(" process")]),e._v(" "),n("p",[e._v("process.argv是命令行参数数组，第一个元素是 node， 第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数。")]),e._v(" "),n("p",[e._v("process.nextTick(callback)的功能是为事件循环设置一项任务， Node.js 会在下次事件循环调响应时调用 callback。")]),e._v(" "),n("p",[e._v("不要使用 setTimeout(fn,0)代替 process.nextTick(callback)，前者比后者效率要低得多。")]),e._v(" "),n("h3",{attrs:{id:"util"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#util","aria-hidden":"true"}},[e._v("#")]),e._v(" util")]),e._v(" "),n("p",[e._v("util.inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。")]),e._v(" "),n("p",[e._v("util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。")]),e._v(" "),n("h3",{attrs:{id:"event"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#event","aria-hidden":"true"}},[e._v("#")]),e._v(" event")]),e._v(" "),n("p",[e._v("这就是EventEmitter最简单的用法。接下来我们介绍一下EventEmitter常用的API。\n EventEmitter.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。\n EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传递若干可选参数到事件监听器的参数表。\n EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。\n EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器， listener 必须是该事件已经注册过的监听器。\n EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。")]),e._v(" "),n("h3",{attrs:{id:"fs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fs","aria-hidden":"true"}},[e._v("#")]),e._v(" fs")]),e._v(" "),n("p",[e._v("fs.readFile(filename,[encoding],[callback(err,data)])是最简单的读取\n文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding\n是可选的，表示文件的字符编码。 callback 是回调函数，用于接收文件的内容。如果不指\n定 encoding，则 callback 就是第二个参数。回调函数提供两个参数 err 和 data， err 表\n示有没有错误发生， data 是文件内容。如果指定了 encoding， data 是一个解析后的字符\n串，否则 data 将会是以 Buffer 形式表示的二进制数据。")]),e._v(" "),n("h3",{attrs:{id:"http"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#http","aria-hidden":"true"}},[e._v("#")]),e._v(" http")]),e._v(" "),n("p",[e._v("http.createServer(function(req, res) {\nres.writeHead(200, {'Content-Type': 'text/html'});\nres.write('")]),n("h1",[e._v("Node.js")]),e._v("');\nres.end('"),n("p",[e._v("Hello World")]),e._v("');\n}).listen(3000);\nconsole.log(\"HTTP server is listening at port 3000.\");\n这段代码中， http.createServer 创建了一个 http.Server 的实例，将一个函数\n作为 HTTP 请求处理函数。这个函数接受两个参数，分别是请求对象（ req ）和响应对象\n（ res ）。在函数体内， res 显式地写回了响应代码 200 （表示请求成功），指定响应头为\n'Content-Type': 'text/html'，然后写入响应体 '"),n("h1",[e._v("Node.js")]),e._v("'，通过 res.end\n结束并发送。最后该实例还调用了 listen 函数，启动服务器并监听 3000 端口。"),n("p"),e._v(" "),n("p",[e._v("http.Server 的事件\nhttp.Server 是一个基于事件的 HTTP 服务器，所有的请求都被封装为独立的事件，\n开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自\nEventEmitter，提供了以下几个事件。\n request：当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是\nhttp.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。\n connection：当 TCP 连接建立时，该事件被触发，提供一个参数 socket，为\nnet.Socket 的实例。 connection 事件的粒度要大于 request，因为客户端在\nKeep-Alive 模式下可能会在同一个连接内发送多次请求。\n close ：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。")]),e._v(" "),n("p",[e._v("req")]),e._v(" "),n("p",[e._v("http.ServerRequest 提供了以下3个事件用于控制请求体\n传输。\n data ：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接\n收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调\n用多次。\n end ：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。\n close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了\n传输，也还是调用close。")]),e._v(" "),n("p",[e._v("res")]),e._v(" "),n("p",[e._v(" response.writeHead(statusCode, [headers])：向请求的客户端发送响应头。\nstatusCode 是 HTTP 状态码，如 200 （请求成功）、 404 （未找到）等。 headers\n是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只\n能调用一次，如果不调用，则会自动生成一个响应头。\n response.write(data, [encoding])：向请求的客户端发送响应内容。 data 是\n一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定\nencoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前，\nresponse.write 可以被多次调用。\n response.end([data], [encoding])：结束响应，告知客户端所有发送已经完\n成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可\n选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于\n等待状态")]),e._v(" "),n("p",[e._v("模块加载机制")]),e._v(" "),n("p",[e._v("Node.js 的模块可以分为两大类，一类是核心模块，另一类是文件模块。核心模块就是\nNode.js 标准 API 中提供的模块，如 fs、 http、 net、 vm 等，这些都是由 Node.js 官方提供\n的模块，编译成了二进制代码。我们可以直接通过 require 获取核心模块，例如\nrequire('fs')。")])])},[],!1,null,null,null);t.default=s.exports}}]);