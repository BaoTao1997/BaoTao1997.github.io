<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>BaoTao的前端日志</title>
    <meta name="description" content="欢迎访问我的前端日志">
    <link rel="icon" href="/hero.png">
    
    <link rel="preload" href="/assets/css/0.styles.1a992bd3.css" as="style"><link rel="preload" href="/assets/js/app.f225858c.js" as="script"><link rel="preload" href="/assets/js/2.672550d7.js" as="script"><link rel="preload" href="/assets/js/41.8de6a957.js" as="script"><link rel="prefetch" href="/assets/js/10.c2729db0.js"><link rel="prefetch" href="/assets/js/11.6652c16a.js"><link rel="prefetch" href="/assets/js/12.c99151b5.js"><link rel="prefetch" href="/assets/js/13.c20a05a6.js"><link rel="prefetch" href="/assets/js/14.1ef90bc5.js"><link rel="prefetch" href="/assets/js/15.48e33afe.js"><link rel="prefetch" href="/assets/js/16.9480cdd8.js"><link rel="prefetch" href="/assets/js/17.2dbe7a92.js"><link rel="prefetch" href="/assets/js/18.d2ff3f51.js"><link rel="prefetch" href="/assets/js/19.bad3ad9a.js"><link rel="prefetch" href="/assets/js/20.f54ae634.js"><link rel="prefetch" href="/assets/js/21.fad4d162.js"><link rel="prefetch" href="/assets/js/22.8ce49b77.js"><link rel="prefetch" href="/assets/js/23.191fcec1.js"><link rel="prefetch" href="/assets/js/24.5d911dd7.js"><link rel="prefetch" href="/assets/js/25.92e6ee1b.js"><link rel="prefetch" href="/assets/js/26.2e6ac599.js"><link rel="prefetch" href="/assets/js/27.771ef2ee.js"><link rel="prefetch" href="/assets/js/28.9ddf0721.js"><link rel="prefetch" href="/assets/js/29.3deeede2.js"><link rel="prefetch" href="/assets/js/3.5f2ab74c.js"><link rel="prefetch" href="/assets/js/30.fe8bff52.js"><link rel="prefetch" href="/assets/js/31.1858abcd.js"><link rel="prefetch" href="/assets/js/32.bfb29c32.js"><link rel="prefetch" href="/assets/js/33.a2ae8076.js"><link rel="prefetch" href="/assets/js/34.531e6b81.js"><link rel="prefetch" href="/assets/js/35.645bc314.js"><link rel="prefetch" href="/assets/js/36.56d7c6c2.js"><link rel="prefetch" href="/assets/js/37.6ea9bf2e.js"><link rel="prefetch" href="/assets/js/38.2c569e14.js"><link rel="prefetch" href="/assets/js/39.0fbb6fc9.js"><link rel="prefetch" href="/assets/js/4.43a614f9.js"><link rel="prefetch" href="/assets/js/40.a2e40f8e.js"><link rel="prefetch" href="/assets/js/42.f34c83ed.js"><link rel="prefetch" href="/assets/js/43.5124ce0a.js"><link rel="prefetch" href="/assets/js/44.5148b76a.js"><link rel="prefetch" href="/assets/js/45.0482d6c2.js"><link rel="prefetch" href="/assets/js/46.dca6e042.js"><link rel="prefetch" href="/assets/js/47.d3d60350.js"><link rel="prefetch" href="/assets/js/48.c5d4232b.js"><link rel="prefetch" href="/assets/js/49.23efdb3a.js"><link rel="prefetch" href="/assets/js/5.c06abc86.js"><link rel="prefetch" href="/assets/js/50.143a9543.js"><link rel="prefetch" href="/assets/js/51.67b5b689.js"><link rel="prefetch" href="/assets/js/52.0a3fb16a.js"><link rel="prefetch" href="/assets/js/6.13d9ab35.js"><link rel="prefetch" href="/assets/js/7.d11a37f8.js"><link rel="prefetch" href="/assets/js/8.69f4770c.js"><link rel="prefetch" href="/assets/js/9.3a968c29.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a992bd3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">BaoTao的前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">博客</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">阅读</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/resume/" class="nav-link">简历</a></div> <a href="https://github.com/BaoTao1997" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">博客</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">阅读</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/resume/" class="nav-link">简历</a></div> <a href="https://github.com/BaoTao1997" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Node.js开发指南</p> <p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事件由 EventEmitter 对象提供。前面提到的 fs.readFile 和 http.createServer 的回调函数都是通过 EventEmitter 来实现的。下面我们用一个简单的例子说明 EventEmitter的用法：
//event.js
var EventEmitter = require('events').EventEmitter;
var event = new EventEmitter();
event.on('some_event', function() {
console.log('some_event occured.');
});
setTimeout(function() {
event.emit('some_event');
}, 1000);
运行这段代码， 1秒后控制台输出了 some_event occured.。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在1000毫秒以后向event 对象发送事件 some_event，此时会调用 some_event 的监听器</p> <p>所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（ emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。图3-5说明了事件循环的原理。</p> <p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口， require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象，因为require 不会重复加载模块，也就是说无论调用多少次 require， 获得的模块都是同一个 。</p> <p>不可以通过对 exports 直接赋值代替对 module.exports 赋值。exports 实际上只是一个和 module.exports 指向同一个对象的变量，它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定module.exports 来改变访问接口。</p> <p>Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p> <p>使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。我们会在第 6 章详细介绍模块的加载顺序。</p> <p>模 式 可通过 require 使用 注册PATH
本地模式 是 否
全局模式 否 是</p> <h3 id="process"><a href="#process" aria-hidden="true" class="header-anchor">#</a> process</h3> <p>process.argv是命令行参数数组，第一个元素是 node， 第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数。</p> <p>process.nextTick(callback)的功能是为事件循环设置一项任务， Node.js 会在下次事件循环调响应时调用 callback。</p> <p>不要使用 setTimeout(fn,0)代替 process.nextTick(callback)，前者比后者效率要低得多。</p> <h3 id="util"><a href="#util" aria-hidden="true" class="header-anchor">#</a> util</h3> <p>util.inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。</p> <p>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。</p> <h3 id="event"><a href="#event" aria-hidden="true" class="header-anchor">#</a> event</h3> <p>这就是EventEmitter最简单的用法。接下来我们介绍一下EventEmitter常用的API。
 EventEmitter.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。
 EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传递若干可选参数到事件监听器的参数表。
 EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。
 EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器， listener 必须是该事件已经注册过的监听器。
 EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。</p> <h3 id="fs"><a href="#fs" aria-hidden="true" class="header-anchor">#</a> fs</h3> <p>fs.readFile(filename,[encoding],[callback(err,data)])是最简单的读取
文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding
是可选的，表示文件的字符编码。 callback 是回调函数，用于接收文件的内容。如果不指
定 encoding，则 callback 就是第二个参数。回调函数提供两个参数 err 和 data， err 表
示有没有错误发生， data 是文件内容。如果指定了 encoding， data 是一个解析后的字符
串，否则 data 将会是以 Buffer 形式表示的二进制数据。</p> <h3 id="http"><a href="#http" aria-hidden="true" class="header-anchor">#</a> http</h3> <p>http.createServer(function(req, res) {
res.writeHead(200, {'Content-Type': 'text/html'});
res.write('</p><h1>Node.js</h1>');
res.end('<p>Hello World</p>');
}).listen(3000);
console.log(&quot;HTTP server is listening at port 3000.&quot;);
这段代码中， http.createServer 创建了一个 http.Server 的实例，将一个函数
作为 HTTP 请求处理函数。这个函数接受两个参数，分别是请求对象（ req ）和响应对象
（ res ）。在函数体内， res 显式地写回了响应代码 200 （表示请求成功），指定响应头为
'Content-Type': 'text/html'，然后写入响应体 '<h1>Node.js</h1>'，通过 res.end
结束并发送。最后该实例还调用了 listen 函数，启动服务器并监听 3000 端口。<p></p> <p>http.Server 的事件
http.Server 是一个基于事件的 HTTP 服务器，所有的请求都被封装为独立的事件，
开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自
EventEmitter，提供了以下几个事件。
 request：当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是
http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。
 connection：当 TCP 连接建立时，该事件被触发，提供一个参数 socket，为
net.Socket 的实例。 connection 事件的粒度要大于 request，因为客户端在
Keep-Alive 模式下可能会在同一个连接内发送多次请求。
 close ：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。</p> <p>req</p> <p>http.ServerRequest 提供了以下3个事件用于控制请求体
传输。
 data ：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接
收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调
用多次。
 end ：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。
 close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了
传输，也还是调用close。</p> <p>res</p> <p> response.writeHead(statusCode, [headers])：向请求的客户端发送响应头。
statusCode 是 HTTP 状态码，如 200 （请求成功）、 404 （未找到）等。 headers
是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只
能调用一次，如果不调用，则会自动生成一个响应头。
 response.write(data, [encoding])：向请求的客户端发送响应内容。 data 是
一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定
encoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前，
response.write 可以被多次调用。
 response.end([data], [encoding])：结束响应，告知客户端所有发送已经完
成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可
选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于
等待状态</p> <p>模块加载机制</p> <p>Node.js 的模块可以分为两大类，一类是核心模块，另一类是文件模块。核心模块就是
Node.js 标准 API 中提供的模块，如 fs、 http、 net、 vm 等，这些都是由 Node.js 官方提供
的模块，编译成了二进制代码。我们可以直接通过 require 获取核心模块，例如
require('fs')。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/BaoTao1997/edit/master/docs/book/node开发指南.md" target="_blank" rel="noopener noreferrer">帮助我完善这篇内容🙏</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f225858c.js" defer></script><script src="/assets/js/2.672550d7.js" defer></script><script src="/assets/js/41.8de6a957.js" defer></script>
  </body>
</html>
