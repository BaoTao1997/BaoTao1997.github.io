<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | BaoTao的前端日志</title>
    <meta name="description" content="欢迎访问我的前端日志">
    <link rel="icon" href="/hero.png">
    
    <link rel="preload" href="/assets/css/0.styles.1a992bd3.css" as="style"><link rel="preload" href="/assets/js/app.f225858c.js" as="script"><link rel="preload" href="/assets/js/2.672550d7.js" as="script"><link rel="preload" href="/assets/js/14.1ef90bc5.js" as="script"><link rel="prefetch" href="/assets/js/10.c2729db0.js"><link rel="prefetch" href="/assets/js/11.6652c16a.js"><link rel="prefetch" href="/assets/js/12.c99151b5.js"><link rel="prefetch" href="/assets/js/13.c20a05a6.js"><link rel="prefetch" href="/assets/js/15.48e33afe.js"><link rel="prefetch" href="/assets/js/16.9480cdd8.js"><link rel="prefetch" href="/assets/js/17.2dbe7a92.js"><link rel="prefetch" href="/assets/js/18.d2ff3f51.js"><link rel="prefetch" href="/assets/js/19.bad3ad9a.js"><link rel="prefetch" href="/assets/js/20.f54ae634.js"><link rel="prefetch" href="/assets/js/21.fad4d162.js"><link rel="prefetch" href="/assets/js/22.8ce49b77.js"><link rel="prefetch" href="/assets/js/23.191fcec1.js"><link rel="prefetch" href="/assets/js/24.5d911dd7.js"><link rel="prefetch" href="/assets/js/25.92e6ee1b.js"><link rel="prefetch" href="/assets/js/26.2e6ac599.js"><link rel="prefetch" href="/assets/js/27.771ef2ee.js"><link rel="prefetch" href="/assets/js/28.9ddf0721.js"><link rel="prefetch" href="/assets/js/29.3deeede2.js"><link rel="prefetch" href="/assets/js/3.5f2ab74c.js"><link rel="prefetch" href="/assets/js/30.fe8bff52.js"><link rel="prefetch" href="/assets/js/31.1858abcd.js"><link rel="prefetch" href="/assets/js/32.bfb29c32.js"><link rel="prefetch" href="/assets/js/33.a2ae8076.js"><link rel="prefetch" href="/assets/js/34.531e6b81.js"><link rel="prefetch" href="/assets/js/35.645bc314.js"><link rel="prefetch" href="/assets/js/36.56d7c6c2.js"><link rel="prefetch" href="/assets/js/37.6ea9bf2e.js"><link rel="prefetch" href="/assets/js/38.2c569e14.js"><link rel="prefetch" href="/assets/js/39.0fbb6fc9.js"><link rel="prefetch" href="/assets/js/4.43a614f9.js"><link rel="prefetch" href="/assets/js/40.a2e40f8e.js"><link rel="prefetch" href="/assets/js/41.8de6a957.js"><link rel="prefetch" href="/assets/js/42.f34c83ed.js"><link rel="prefetch" href="/assets/js/43.5124ce0a.js"><link rel="prefetch" href="/assets/js/44.5148b76a.js"><link rel="prefetch" href="/assets/js/45.0482d6c2.js"><link rel="prefetch" href="/assets/js/46.dca6e042.js"><link rel="prefetch" href="/assets/js/47.d3d60350.js"><link rel="prefetch" href="/assets/js/48.c5d4232b.js"><link rel="prefetch" href="/assets/js/49.23efdb3a.js"><link rel="prefetch" href="/assets/js/5.c06abc86.js"><link rel="prefetch" href="/assets/js/50.143a9543.js"><link rel="prefetch" href="/assets/js/51.67b5b689.js"><link rel="prefetch" href="/assets/js/52.0a3fb16a.js"><link rel="prefetch" href="/assets/js/6.13d9ab35.js"><link rel="prefetch" href="/assets/js/7.d11a37f8.js"><link rel="prefetch" href="/assets/js/8.69f4770c.js"><link rel="prefetch" href="/assets/js/9.3a968c29.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a992bd3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">BaoTao的前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">博客</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">面试题</a></div><div class="nav-item"><a href="/book/" class="nav-link">阅读</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/resume/" class="nav-link">简历</a></div> <a href="https://github.com/BaoTao1997" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">博客</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">面试题</a></div><div class="nav-item"><a href="/book/" class="nav-link">阅读</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/resume/" class="nav-link">简历</a></div> <a href="https://github.com/BaoTao1997" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端基础知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/html.html" class="sidebar-link">Html</a></li><li><a href="/interview/css.html" class="sidebar-link">CSS</a></li><li><a href="/interview/js.html" class="sidebar-link">js</a></li><li><a href="/interview/node.html" class="sidebar-link">node</a></li><li><a href="/interview/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/interview/vue.html" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/vue.html#vue相关问题" class="sidebar-link">Vue相关问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/vue.html#_1-vue的双向绑定原理" class="sidebar-link">1.Vue的双向绑定原理</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_2-vue组件通信" class="sidebar-link">2.Vue组件通信</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_3-vue的生命周期" class="sidebar-link">3.Vue的生命周期</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_4-vue和react的区别" class="sidebar-link">4.Vue和React的区别</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_5-vue项目性能优化" class="sidebar-link">5.Vue项目性能优化</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_6-vuex解决了什么问题" class="sidebar-link">6.Vuex解决了什么问题</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_7-讲讲vue的diff算法" class="sidebar-link">7.讲讲Vue的diff算法</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_8-mvc和mvvm的区别" class="sidebar-link">8.MVC和MVVM的区别</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_9-vue组件实现方式汇总" class="sidebar-link">9.Vue组件实现方式汇总</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_10-vue的computed和watch有什么区别？" class="sidebar-link">10.Vue的computed和watch有什么区别？</a></li><li class="sidebar-sub-header"><a href="/interview/vue.html#_11-vue的nexttick实现原理和应用场景？" class="sidebar-link">11.Vue的nextTick实现原理和应用场景？</a></li></ul></li></ul></li><li><a href="/interview/react.html" class="sidebar-link">react</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法与网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/network.html" class="sidebar-link">网络</a></li><li><a href="/interview/algorithm.html" class="sidebar-link">算法</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue相关问题"><a href="#vue相关问题" aria-hidden="true" class="header-anchor">#</a> Vue相关问题</h2> <h3 id="_1-vue的双向绑定原理"><a href="#_1-vue的双向绑定原理" aria-hidden="true" class="header-anchor">#</a> 1.Vue的双向绑定原理</h3> <p>vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的，通过Object.defineProperty()[<em>对象，对象上的属性，描述符</em>]来劫持对象属性的setter和getter操作实现数据驱动视图。具体参考<a href="https://baotao1997.github.io/blog/framework-mvvm.html" target="_blank" rel="noopener noreferrer">MVVM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li>Vue如何实现监听数组的<code>push</code>，<code>pop</code>和<code>splice</code>方法？</li></ul> <p>Object.defineProperty对数组进行响应式化是有缺陷的，虽然我们可以监听到索引的改变，但是defineProperty不能检测到数组长度的变化，准确的说是通过改变length而增加的长度不能监测到。</p> <p>虽然我们无法使用Object.defineProperty将数组进行响应式的处理，也就是getter-setter，但是还有其他的功能可以供我们使用。就是数据描述符，数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。</p> <p><strong>value</strong></p> <p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p> <p><strong>writable</strong></p> <p>当且仅当该属性的writable为true时，value才能被<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators" target="_blank" rel="noopener noreferrer">赋值运算符<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>改变。默认为 false。</p> <p>因此我们只要把原型上的方法，进行value的重新赋值。</p> <p>如下代码，在重新赋值的过程中，我们可以获取到方法名和所有参数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">def</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">value</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'args'</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 重写的数组方法</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 数组方法的绑定</span>
<span class="token function">def</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'push'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 控制台输出 key push</span>
<span class="token comment">// 控制台输出 args [Array(2), 7, &quot;hello!&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><strong>Vue监听Array</strong></p> <p>第一步：先获取原生 Array 的原型方法，因为拦截后还是需要原生的方法帮我们实现数组的变化。</p> <p>第二步：对 Array 的原型方法使用 Object.defineProperty 做一些拦截操作。</p> <p>第三步：把需要被拦截的 Array 类型的数据原型指向改造后原型。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype <span class="token comment">// 获取Array的原型</span>
 
<span class="token keyword">function</span> <span class="token function">def</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">value</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制台输出 push</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制台输出 [Array(2), 7, &quot;hello!&quot;]</span>
       
      <span class="token comment">// 获取原生的方法</span>
      <span class="token keyword">let</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 将开发者的参数传给原生的方法，保证数组按照开发者的想法被改变</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      <span class="token comment">// do something 比如通知Vue视图进行更新</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的数据被改变了，视图该更新啦'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'hello Vue'</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新的原型</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 重写赋值</span>
<span class="token function">def</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'push'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 原型的指向重写</span>
arr<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> obj<span class="token punctuation">;</span>
<span class="token comment">// 执行push</span>
arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h3 id="_2-vue组件通信"><a href="#_2-vue组件通信" aria-hidden="true" class="header-anchor">#</a> 2.Vue组件通信</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>对于多组件之间的状态共享<span class="token punctuation">,</span>我们需要通过state规定统一的数据仓库<span class="token punctuation">,</span>
只能通过Action和Mutation实现数据的更改<span class="token punctuation">,</span>然后实现多组件的数据同时改变
总结<span class="token punctuation">:</span>props父传子<span class="token punctuation">,</span>$emit自定义事件子传父<span class="token punctuation">:</span><span class="token function">都是</span><span class="token punctuation">(</span>vue命令<span class="token punctuation">)</span>子组件内容 <span class="token operator">=</span> 父组件内容
<span class="token number">1.</span>父组件向子组件传值
父组件中的 v<span class="token operator">-</span>bind<span class="token punctuation">:</span>'<span class="token function">子组件props中的属性名称</span><span class="token punctuation">(</span>若子组件props中的名称为myName<span class="token punctuation">,</span>
由于<span class="token constant">HTML</span>特性不区分大小写<span class="token punctuation">,</span>所以这里采用my<span class="token operator">-</span>name<span class="token punctuation">)</span><span class="token string">'='</span>父组件中的属性名称'
注意如果是静态字符串则可以不用v<span class="token operator">-</span>bind<span class="token punctuation">,</span>否则必须使用
<span class="token number">2.</span><span class="token function">子组件向父组件传值</span><span class="token punctuation">(</span>自定义事件<span class="token punctuation">,</span>回调函数<span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">--</span>自定义事件<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
子组件通过事件<span class="token string">'$emit('</span>modify<span class="token string">', this.modifylist);'</span>传递消息给父组件<span class="token punctuation">,</span>
再用v<span class="token operator">-</span>on<span class="token punctuation">:</span><span class="token string">'子组件事件名称'</span><span class="token operator">=</span><span class="token string">'父组件事件名称'</span>
简化写法即为<span class="token template-string"><span class="token string">`v-model`</span></span><span class="token punctuation">(</span>主要用于表单的双向绑定<span class="token punctuation">)</span><span class="token punctuation">,</span>实际上是
<span class="token template-string"><span class="token string">`&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;`</span></span>
相当于：<span class="token template-string"><span class="token string">`&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;name = $event.target.value&quot;&gt;`</span></span>
<span class="token operator">--</span><span class="token operator">--</span>回调函数<span class="token operator">--</span><span class="token operator">--</span>
通过<span class="token string">'v-bind:callback=&quot;callback&quot;'</span><span class="token punctuation">,</span>用props将回调函数传给子组件<span class="token punctuation">,</span>
然后在子组件中用v<span class="token operator">-</span>on<span class="token punctuation">:</span>click<span class="token operator">=</span><span class="token string">&quot;callback&quot;</span>绑定该方法
<span class="token number">3.</span><span class="token function">兄弟组件传值</span><span class="token punctuation">(</span>可以用一个父组件做中继<span class="token punctuation">,</span>也可以用事件总线<span class="token punctuation">,</span>介绍一下事件总线<span class="token punctuation">)</span>
新建一个bus<span class="token punctuation">.</span><span class="token function">js</span><span class="token punctuation">(</span>事件总线EventBus<span class="token punctuation">)</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'Vue'</span>
<span class="token keyword">const</span> eventbus <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> eventbus<span class="token punctuation">;</span>
并在兄弟组件中引入<span class="token punctuation">,</span>然后<span class="token punctuation">:</span>
组件<span class="token number">1</span>用eventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'1to2'</span><span class="token punctuation">,</span> <span class="token string">'emmit'</span><span class="token punctuation">)</span>
组件<span class="token number">2</span>则用eventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'1to2'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fromBrother <span class="token operator">=</span> message<span class="token punctuation">}</span><span class="token punctuation">)</span> 保证事件名称相同
<span class="token number">4.</span>更深层次的注入provide<span class="token operator">/</span>inject
在组件中使用provide<span class="token punctuation">:</span>
<span class="token function-variable function">provide</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    getMap<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>getMap
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
其所有的子组件及后代可以通过inject来进行获取getMap方法<span class="token punctuation">:</span>
inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'getMap'</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>Tips：Vue父子组件传值传引用类型的时候，修改父组件对象中的某个值，利用props则发现子组件使用相应属性时没有发生修改，具体操作方式有：</p> <ul><li>通过深拷贝拷贝传入子组件的对象，则能够实现监听</li> <li>通过子组件中使用<code>watch</code>对修改的对象的某个属性进行监听</li></ul> <h3 id="_3-vue的生命周期"><a href="#_3-vue的生命周期" aria-hidden="true" class="header-anchor">#</a> 3.Vue的生命周期</h3> <p><img src="/assets/img/1.6e0f0d40.png" alt="img"></p> <p>vue源码中最终执行生命周期函数都是调用<code>callHook</code>方法，<code>callHook</code>函数的逻辑很简单，根据传入的生命周期类型 <code>hook</code>，去拿到 <code>vm.$options[hook]</code>对应的回调函数数组，然后遍历执行，执行的时候把 <code>vm</code>作为函数执行的上下文。</p> <ol><li><p><code>new Vue(options)</code>：创建一个vm实例；</p></li> <li><p><code>mergeOptions(resolveConstructorOptions(vm.constructor), options, vm)</code>：合并Vue构造函数里options和传入的options或合并父子的options。比如：在mergeOptions函数中会调用mergeHook方法合并生命周期的钩子函数，mergeHook方法原理是只有父时返回父，只有子时返回数组类型的子。<strong>父、子都存在时，将子添加在父的后面返回组合而成的数组。这也是父子均有钩子函数的时候，先执行父的后执行子的的原因；</strong></p></li> <li><p><code>initLifecycle(vm)、initEvents(vm)、initRender(vm)</code>：在创建的vm实例上初始化生命周期、事件、渲染相关的属性；</p></li> <li><p><code>callHook(vm, 'beforeCreate')</code>：调用beforeCreate生命周期钩子函数；</p></li> <li><p><code>initInjections(vm)、initState(vm)、initProvide(vm)</code>：初始化数据：inject、state、provide。initState 的作用是初始化 props、data、methods、watch、computed 等属性；</p></li> <li><p><code>callHook(vm, 'created')</code>：调用created生命周期钩子函数；</p></li> <li><p><code>vm.$mount(vm.$options.el)</code>：<code>$mount</code>方法在多个文件中都有定义，如&quot;src/platform/web/entry-runtime-with-compiler.js&quot;、&quot;src/platform/web/runtime/index.js&quot;、&quot;src/platform/weex/runtime/index.js&quot;。因为<code>$mount</code>方法的实现是和平台、构建方式相关的。以&quot;entry-runtime-with-compiler.js&quot;为例，关键步骤是查看<code>vm.$options</code>中是否有render方法，如果没有则会根据el和template属性确定最终的template字符串，再调用<code>compileToFunctions</code>方法将template字符串转为render方法，最后，调用原先原型上的$mount方法，即开始执行&quot;lifecycle.js&quot;中<code>mountComponent</code>方法；</p></li> <li><p><code>callHook(vm, 'beforeMount')</code>：调用beforeMount生命周期钩子函数；</p></li> <li><p><code>vm._render()</code> =&gt; <code>vm._update()</code> =&gt; <code>vm.__patch__()</code>：先执行vm._render方法，即调用createElement生成虚拟DOM，即VNode ，每个VNode有children ，children 每个元素也是⼀个 VNode，这样就形成了⼀个 VNode Tree；再调用vm._update方法进行首次渲染，vm._update方法核心是调用vm.<strong>patch</strong>方法，这个方法跟vm.$mount一样跟平台相关；vm.<strong>patch</strong>方法则是根据生成的VNode Tree递归createElm方法创建真实Dom Tree挂载到Dom上；</p></li> <li><p><code>callHook(vm, 'mount')</code>：调用mount生命周期钩子函数：VNode patch 到 Dom 之后会执行 'invokeInsertHook'函数，把<code>insertedVnodeQueue</code>中保存的mount钩子函数执行一遍，<strong>insertedVnodeQueue队列中的钩子函数是在根据VNode Tree递归createElm方法创建真实Dom Tree过程生成的钩子函数顺序队列，因此mounted钩子函数的执行顺序是先子后父；</strong></p></li> <li><p><code>data changes</code>：数据更新，nextTick中执行<code>flushSchedulerQueue</code>方法，该方法会执行watcher队列中的watcher；</p></li> <li><p><code>callHook(vm, 'beforeUpdate')</code>：执行watcher时会执行watcher的before方法，即调用beforeUpdate生命周期钩子函数；</p></li> <li><p><code>Virtual DOM re-render and patch</code>：重新render生成新的Virtual DOM，并且patch到DOM上；</p></li> <li><p><code>callHook(vm, 'updated')</code>：调用updated生命周期钩子函数；</p></li> <li><p><code>vm.$destroy()</code>：启动卸销毁过程；</p></li> <li><p><code>callHook(vm, 'beforeDestroy')</code>：调用beforeDestroy生命周期钩子函数；</p></li> <li><p><code>Teardown watchers, childcomponents and event listeners</code>：执行一系列销毁动作，在 $destroy 的执行过程中，它又会执行<code>vm.__patch__(vm._vnode, null)</code> 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroyed 钩子函数执行顺序是先子后父，和 mounted 过程一样。</p></li> <li><p><code>callHook(vm, 'destroyed ')</code>：调用destroyed 生命周期钩子函数。</p></li></ol> <h4 id="errorcaptured生命周期钩子函数"><a href="#errorcaptured生命周期钩子函数" aria-hidden="true" class="header-anchor">#</a> <code>errorCaptured</code>生命周期钩子函数</h4> <ul><li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</li> <li>如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。</li> <li>默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</li></ul> <h4 id="keep-alive组件"><a href="#keep-alive组件" aria-hidden="true" class="header-anchor">#</a> keep-alive组件</h4> <ul><li><p>keep-alive组件是vue的**内置抽象（abstract）**组件，抽象组件在initLifecycle过程中 组件实例建立父子关系时会被忽略，因此他自身不会渲染一个DOM元素，也不会出现在父组件链中。</p></li> <li><p>keep-alive作用是用于包裹动态组件，缓存不活动的组件实例。keep-alive自定义实现了render函数并利用了插槽slot，render函数中先获取它的默认插槽，再获取到它的第一个组件子节点，因此keep-alive组件只处理第一个子元素，所以一般和它搭配使用的有component动态组件或者router-view。</p></li> <li><p>keep-alive组件在created钩子中定义了 this.cache 和 this.keys，本质上是去缓存已创建的 <strong>vnode</strong>，缓存策略采用<strong>LRU策略</strong>，每次缓存命中时将当前vnode移到缓存数组末尾，需要删除时则删除缓存数组第一个vnode。</p></li> <li><p>keep-alive组件接收三个props：</p> <ol><li><p><code>include</code>：数组、字符串或者正则表达式，只有匹配的组件才会缓存。</p></li> <li><p><code>exclude</code>：数组、字符串或者正则表达式，任何匹配的组件都不会被缓存。</p></li> <li><p><code>max</code>：字符串或数字，指定可以缓存的组件最大个数，如果个数超过max，则销毁缓存数组中的第一个组件。</p></li></ol></li> <li><p>keep-alive组件子组件渲染机制：</p> <ol><li><p>首次渲染：和普通组件一样执行正常的init生命周期钩子函数，同时将生成的vnode缓存到内存中；</p></li> <li><p>组件切换：切换到新组件时，旧组件不会销毁，而是变成未激活状态，即不会执行destroy相关的钩子函数，而是执行 <code>deactivated</code> 生命周期钩子函数，如果新组件不在缓存数组中，则执行首次渲染，否则执行缓存渲染；</p></li> <li><p>缓存渲染：缓存渲染即组件由未激活状态变成激活状态，因此不会执行created、mounted等钩子函数，而是执行 <code>activated</code> 生命周期钩子函数。</p></li></ol></li></ul> <h3 id="_4-vue和react的区别"><a href="#_4-vue和react的区别" aria-hidden="true" class="header-anchor">#</a> 4.Vue和React的区别</h3> <p>相同点：</p> <ol><li>虚拟 DOM</li> <li>组件化</li> <li>保持对视图的关注</li> <li>数据驱动视图</li> <li>都有支持 native 的方案</li></ol> <p>不同点：</p> <ol><li>state 状态管理 vs 对象属性 get，set。</li> <li>vue 实现了数据的双向绑定 v-model，而组件之间的 props 传递是单向的，react 数据流动是单向的。</li></ol> <h4 id="运行时优化"><a href="#运行时优化" aria-hidden="true" class="header-anchor">#</a> 运行时优化</h4> <p>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树，开发者不得不手动使用 shouldComponentUpdate 去优化性能。</p> <p>在 Vue 组件的依赖是在渲染过程中自动追踪的，开发者不再需要考虑此类优化。另外 Vue 还做了很多其他方面的优化，例如：标记静态节点，优化静态循环等。</p> <blockquote><p>总结：Vue 在运行时帮我们做了很多优化了处理，开发者可以直接上手，React 则是由开发者自己去处理优化，让程序有更多的定制化。</p></blockquote> <h4 id="jsx-vs-templates"><a href="#jsx-vs-templates" aria-hidden="true" class="header-anchor">#</a> JSX vs Templates</h4> <p>JSX 中你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。</p> <p>Templates 对于很多习惯了 HTML 的开发者来说，模板比起 JSX 读写起来更自然。基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。你甚至可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。</p> <blockquote><p>总结：Vue 在模板上实现定制化，可以使用类 HTML 模板，以及可以使用 JSX，React 则是推荐 JSX。</p></blockquote> <h3 id="_5-vue项目性能优化"><a href="#_5-vue项目性能优化" aria-hidden="true" class="header-anchor">#</a> 5.Vue项目性能优化</h3> <h4 id="路由懒加载"><a href="#路由懒加载" aria-hidden="true" class="header-anchor">#</a> 路由懒加载</h4> <p>将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身),使用动态 import语法来定义代码分块点 (split point):</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./Foo.vue'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="代码优化"><a href="#代码优化" aria-hidden="true" class="header-anchor">#</a> 代码优化</h4> <ul><li>v-if 和 v-show选择调用</li> <li>细分vuejs组件，组件按需加载</li> <li>减少watch的数据</li> <li>利用<code>vue-lazy</code>实现图片懒加载</li> <li>SSR</li> <li>webpack配置：js打包多个文件，压缩图片（<code>npm run build --report</code>查看打包体积问题）</li></ul> <h4 id="用户体验"><a href="#用户体验" aria-hidden="true" class="header-anchor">#</a> 用户体验</h4> <ul><li>loading图</li> <li>骨架屏</li> <li>点击延迟</li></ul> <h3 id="_6-vuex解决了什么问题"><a href="#_6-vuex解决了什么问题" aria-hidden="true" class="header-anchor">#</a> 6.Vuex解决了什么问题</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>1.多个组件共享状态时，单向数据流的简洁性很容易被破坏：
2.多个视图依赖于同一状态。
3.来自不同视图的行为需要变更同一状态。
Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）
通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到state
主要有这五个模块：
getter mutation action state module
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_7-讲讲vue的diff算法"><a href="#_7-讲讲vue的diff算法" aria-hidden="true" class="header-anchor">#</a> 7.讲讲Vue的diff算法</h3> <p>虚拟DOM：用JS对象来表示DOM对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> Vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span> tag<span class="token punctuation">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> text<span class="token punctuation">:</span> <span class="token string">'123'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>diff比较方式：比较新旧节点只会<strong>同层级比较</strong>，第一层不一样则不会继续比较（实际上Vue的diff算法是<strong>广度优先</strong>）</p> <p>先patchVnode新旧节点，不是同一个节点则replace，否则判断子节点：</p> <ul><li>找到对应的真实dom，称为el</li> <li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li> <li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li> <li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li> <li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li> <li>如果两者都有子节点，则执行updateChildren函数比较子节点</li></ul> <p>updateChild实现过程：</p> <ul><li>将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</li> <li>oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</li></ul> <h3 id="_8-mvc和mvvm的区别"><a href="#_8-mvc和mvvm的区别" aria-hidden="true" class="header-anchor">#</a> 8.MVC和MVVM的区别</h3> <ul><li>Model用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法；</li> <li>View作为视图层，主要负责数据的展示；</li> <li>Controller定义用户界面对用户输入的响应方式，它连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变。</li></ul> <p>MVC将响应机制封装在controller对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。 MVVM把View和Model的同步逻辑自动化了。以前Controller负责的View和Model同步不再手动地进行更新操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它View显示的数据对应的是Model哪一部分即可。也就是双向数据绑定，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。</p> <h3 id="_9-vue组件实现方式汇总"><a href="#_9-vue组件实现方式汇总" aria-hidden="true" class="header-anchor">#</a> 9.<a href="https://www.mybj123.com/2918.html" target="_blank" rel="noopener noreferrer">Vue组件实现方式汇总<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ul><li><p>v-model语法糖实现同步父子组件</p></li> <li><p>表单验证则是通过获取子组件实例进行封装</p></li> <li><p>全局弹窗组件则是通过手动mounted挂载实现</p></li> <li><p>也可以使用Vue的高阶组件实现throttle或者debounce的封装</p></li></ul> <h3 id="_10-vue的computed和watch有什么区别？"><a href="#_10-vue的computed和watch有什么区别？" aria-hidden="true" class="header-anchor">#</a> 10.Vue的computed和watch有什么区别？</h3> <ul><li>computed特性</li></ul> <p>1.是计算值，
2.应用：就是简化tempalte里面{{}}计算和处理props或$emit的传值
3.具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</p> <ul><li>watch特性</li></ul> <p>1.是观察的动作，
2.应用：监听props，$emit或本组件的值执行异步操作
3.无缓存性，页面重新渲染时值不变化也会执行</p> <p><a href="https://segmentfault.com/a/1190000010408657" target="_blank" rel="noopener noreferrer">computed原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1. data 属性初始化 getter setter
2. computed 计算属性初始化，提供的函数将用作属性 vm.reversedMessage 的 getter
3. 当首次获取 reversedMessage 计算属性的值时，Dep 开始依赖收集
4. 在执行 message getter 方法时，如果 Dep 处于依赖收集状态，则判定 message 为 reversedMessage 的依赖，并建立依赖关系
5. 当 message 发生变化时，根据依赖关系，触发 reverseMessage 的重新计算
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_11-vue的nexttick实现原理和应用场景？"><a href="#_11-vue的nexttick实现原理和应用场景？" aria-hidden="true" class="header-anchor">#</a> 11.Vue的nextTick实现原理和应用场景？</h3> <p>Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p> <p>例如，当你设置 <code>vm.someData = 'new value'</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。</p> <p>在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。</p> <p>官方文档说明：</p> <blockquote><p>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</p></blockquote> <p>nextTick将需要延迟的函数放到了一个异步队列中执行,setTimeout或Promise等，来起到延迟执行的作用。</p> <p>很多用途都是用于将函数放到Dom更新后执行，比如在created生命周期中拿不到dom因为还没渲染挂载到页面，这时就需要将对dom的操作放到nexttick函数中。那么为什么nexttick中的函数能延迟到dom更新完成后呢？</p> <p>因为采用的是异步回调，所有异步函数都会在同步函数执行完之后在进行调用，而DOM的更新在同一事件循环中是同步的，所以能在其后执行。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/BaoTao1997/edit/master/docs/interview/vue.md" target="_blank" rel="noopener noreferrer">帮助我完善这篇内容🙏</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">更新时间: </span> <span class="time">8/6/2019, 10:57:44 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/interview/webpack.html" class="prev">
          webpack
        </a></span> <span class="next"><a href="/interview/react.html">
          react
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f225858c.js" defer></script><script src="/assets/js/2.672550d7.js" defer></script><script src="/assets/js/14.1ef90bc5.js" defer></script>
  </body>
</html>
